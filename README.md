User-Store
==========

Generic storage for user accounts that is meant to be flexible and provide a minimalistic default interface.

It has barebone optional built-in facilities to handle password authentication and roles.

Requirements
============

- A recent version of MongoDB (version 2.4.9 is installed on my machine) [1]

- A recent version of Node.js (version 0.10.25 is installed on my machine) [1]

- npm if you want the easy way to install this module.

[1] Later versions should also work. If you find it not to be the case, let me know.

Installation
============

npm install user-store

Running Tests
=============

In the directory where the module is located, run the following 2 commands on the prompt:

- npm install
- npm test

Overall Concept
===============

This module makes use of MongoDB's shema-free design to be unbiased about what information you store for your users and what information you use to identify them.

Is uses a basic Add/Get/Update/Remove methods to manipulate users. Additionally, AddMembership and RemoverMembership methods are provided to operate on a user's Memberships set in order to abstract away MongoDB's set manipulation.

All its functions take a &lt;User&gt; object as an argument that you can defined with whichever custom fields you want (ex: Username, Email, FistName, LastName, etc).

The only special fields in &lt;User&gt; are 'Password' (which is hashed internally and used to authentify users if present) and 'Memberships' (which is returned for the 'Get' accessor and contain memberships).

Constructor
===========

The constructor for the user-store module has the following signature:

function(&lt;DB&gt;, &lt;Restrictions&gt;, &lt;Callback&gt;, &lt;Options&gt;)

A barebone call to this function would look like this:

```javascript
var Mongodb = require('mongodb');
var UserStore = require('user-store');

//Probably some code

MongoDB.MongoClient.connect("mongodb://localhost:27017/SomeDatabase", {native_parser:true}, function(Err, DB) { //Your code will probably differ here
    UserStore(Context['DB'], {}, function(Err, Store) {
    
    //Do stuff with the Store instance
    
    });
});
```

- &lt;DB&gt;: Is the database handle generated by Node's MongoDB driver that you are passing to the user store to operate on the desired database.

- &lt;Restrictions&gt;:

The &lt;Restrictions&gt; options takes the following format:

{&lt;FieldA&gt;: {&lt;FieldARestrictions&gt;}, &lt;FieldB&gt;: {&lt;FieldBRestrictions&gt;}, etc}

The rectrictions properties for a field are 'Unique' and 'NotNull' (both which should take the value of 1 if activated).

'Unique' ensures that the field, if present, is unique for all users and 'NotNull' ensures that it is not null.

The 'Unique' property is enforced internally with a unique index. The 'NotNull' property is enforced in the Add method of user-store.

For those who are more savvy about how MongoDB indexes work, if 'Unique' is specified, but 'NotNull' is not, a unique sparse index will be created. 

Ex:

```javascript

//some Code

//Assume that Email needs to be present and unique. FirstName needs to be present, but doesn't need to be unique. Username doesn't need to be present, but should be unique if present.

UserStore(Context['DB'], {'Email': {'Unique': 1, 'NotNull': 1}, 'FirstName': {'NotNull': 1}, 'Username': {'Unique': 1}}, function(Err, Store) {

//some code

});
```

- &lt;Callback&gt;:

&lt;Callback&gt; is a function that takes the following signature: function(&lt;Err&gt;, &lt;Store&gt;)

&lt;Err&gt; is defined if there was an error and &lt;Store&gt; is the user-store instance that you can call methods on to access or manipulate users.

- &lt;Options&gt;:

It is an object containing various options you can set for the user-store instance (they all have defaults so it can be omitted).

The options are as follow:

-CollectionName: The collection name that the user-store instance will use to store/manipulate users. It defaults to 'Users'.

-MembershipsArray: 

If set to true (default), an empty array ([]) will automatically be added to the Memberships property of all users generated with the Add method.

This is a convenience method to provide a unified feel when retrieving users. Without it, the Memberships property will be undefined for users until the AddMembership method is first call for that user.

If you do not plan on using the memberships API of user-store, you can set this to false.

-KeyLength:

Length of the hashed passwords if the default hashing is used. Greater lengths Defaults to 20.

-Iterations:

Correlates to the time it will take to hash using the default hashing algorithm. Greater values will make stored passwords harder to brute-force if you user store gets stolen (assume it will), but will take more time to process.

The greatest value you can manage given your expected traffic and server hardware is preferable. 

It defaults to 10000.

-Hash,Verify:

Those options should be defined together and override the default password hash facility with a custom one (useful for those wishing to use bcrypt for example).

'Hash' takes the following signature: function(&lt;Password&gt;, &lt;Callback&gt;)

Here, &lt;Password&gt; is a plaintext password and &lt;Callback&gt; is called once hashing is completed and expects an error object (if any else null) as its first argument and the hashed password as its second.

'Verify' takes the following signature: function(&lt;Password&gt;, &lt;Hash&gt;, &lt;Callback&gt;)

Here, &lt;Password&gt; is the plaintext password to verify, &lt;Hash&gt; is the hashed password to verify the plaintext against and &lt;Callback&gt; is called once the verification is complete and expects an error object (if any else null) as its first argument and a boolean indicating whether or not the password matched as its second.

Ex:

```javascript
//Custom bcrypt implementation taken directly from the tests
var Bcrypt = require('bcrypt');

//Probably some code

var HandleError = UserStore.prototype.UnitTests.HandleError;

function BcryptHash(Password, Callback)
{
    Bcrypt.genSalt(10, function(Err, Salt) {
        HandleError(Err, Callback, function() {
            Bcrypt.hash(Password, Salt, function(Err, Hash) {
                Callback(Err, Hash);
            });
        });
    });
}

function BcryptVerify(Password, Hash, Callback)
{
    Bcrypt.compare(Password, Hash, function(Err, Result) {
        Callback(Err, Result);
    });
}

//More code

var StoreOptions = {'Hash': BcryptHash, 'Verify': BcryptVerify};

UserStore(SomeDBHandle, SomeRestrictions, function(Err, Store) {
    //Hopefully some code here
}, StoreOptions);

```

-Indices: Contains an array of custom indices that you may wish to define on the Users collection. It takes the following form:

[&lt;Index1&gt;, &lt;Index2&gt;, etc], where &lt;Indexi&gt; takes the following form:

{'Fields': &lt;Fields&gt;, 'Options': &lt;Options&gt;}, where &lt;Fields&gt; and &lt;Options&gt; correspond to the arguments you would pass to an 'ensureIndex' call on a 'collection' object using the native MongoDB driver. 

ex:

```javascript
//Some code here

//Assume we live in a world were the combination of a person's first name and family name uniquely identifies him

var StoreOptions = {};
StoreOptions['Indices'] = [{'Fields': {'FirstName': 1, 'LastName': 1}, 'Options': {'unique': true}}];

UserStore(SomeDBHandle, {'FirstName': {'NotNull': 1}, 'LastName': {'NotNull': 1}}, function(Err, Store) {

//Hopefully some code here

}, StoreOptions);

```


Instance Methods
================

Add
---

Method to add users. It has the following signature: function(&lt;User&gt;, &lt;Callback&gt;)

&lt;User&gt; is an object that contains the fields that define your user (ex: Email, Username, Password, etc). If 'Password' is one of those fields, it will be hashed internally (either by the default hashing method or a custom one you passed in the constructor).

Also, if you plan on using the membership API, 'Memberships' shouldn't be defined in <User> (the library will take care of that for you).

&lt;Callback&gt; will have an error as its first arguments and the result as its second (which is an array containing generated users).

Ex:

```javascript
//Some code

Store.Add({'Email': 'SomeEmail@email.com', 'Username': 'SomeUser', 'Password': 'qwerty!'}, function(Err, Result) {

    if(Err)
    {
        if(Err.UserStore && Err.UserStore.Name == 'ConstraintError')
        {
            if(Err.UserStore.Type == 'NotNull')
            {
                //NotNull constraint violation, handle it
            }
            else
            {
                //Unique constraint violation, handle it
            }
        }
        else
        {
            //Some other database error occured
        }
    }
    else if(Result.length==1)
    {
        //User was successfully created, yay!
    }

});

```

Note: While the NotNull and Unique restrictions will cause an error to be returned if those properties are not respected during insertion, the returned error will have the following properties:

- UserStore.Name: Will have the value 'ConstraintError'.

- UserStore.Type: will have the value 'NotNull' or 'Unique', depending on which constraint was not respected.

Checking for the existence of the 'UserStore' property in the error object with the above values is an easy way to separate constraint-caused errors from system errors.

Get
---

Method to get a specific user. It has the following signature: function(&lt;User&gt;, &lt;Callback&gt;)

&lt;User&gt; is an object that only needs to contain the right fields to uniquely identify your user. If 'Password' is defined, it will be hashed and used to authenticate the user.

&lt;Callback&gt; will have an error as its first argument and the users as its second (if it was sucessfully retried, else null).

Ex:

```javascript
//Some code

//Here, we pass a plaintext password so we expect successful authentication in order to retrieve the user 
//This might get called on behalf of a user trying to login.
Store.Get({'Email': 'SomeEmail@email.com', 'Password': 'password!'}, function(Err, User) {
    if(Err)
    {
        //Some error occured, handle it. Probably the database.
    }
    else if(User)
    {
        //User successfully retrieved. 
    }
    else
    {
        //User was not successfully retrieved. Probably a wrong email or wrong password
    }
});
```

```javascript
//Some code

//Here, we don't pass a password so we don't expect authentication to retrieve the user.
//Maybe we perform authentication elsewhere using another method or maybe we are retrieving user information from an admin panel.

Store.Get({'Email': 'SomeEmail@email.com'}, function(Err, User) {
    if(Err)
    {
        //Some error occured, handle it. Probably the database.
    }
    else if(User)
    {
        //User successfully retrieved. 
    }
    else
    {
        //User was not successfully retrieved. Probably a wrong email.
    }
});

```

Remove
------

Method to delete one or more users. It has the following signature: function(&lt;User&gt;, &lt;Callback&gt;)

&lt;User&gt; is an object that only needs to contain the right fields to identify the user(s) we want to delete. If 'Password' is defined, it will be hashed and used to authenticate the user.

&lt;Callback&gt; will have an error as its first argument and the number of deleted users as its second.

Ex:

```javascript
//Some code

//Here, we pass a plaintext password so we expect successful authentication in order to delete the user 
//This might get called on behalf of a user trying to delete his account.
Store.Remove({'Email': 'SomeEmail@email.com', 'Password': 'password!'}, function(Err, Result) {
    if(Err)
    {
        //Some error occured, handle it. Probably the database.
    }
    else if(Result==1)
    {
        //User was successfully deleted.
    }
    else if(Result==0)
    {
        //User was not successfully deleted. Probably a wrong email or wrong password
    }
});
```

```javascript
//Some code

//Here, we pass a plaintext password is not provided so authentication is not performed.
//This might get called on behalf of an administrator using an admin panel or a user that was authenticated with another method.
Store.Remove({'Email': 'SomeEmail@email.com'}, function(Err, Result) {
    if(Err)
    {
        //Some error occured, handle it. Probably the database.
    }
    else if(Result==1)
    {
        //User was successfully deleted.
    }
    else if(Result==0)
    {
        //User was not successfully deleted. Probably a wrong email.
    }
});
```

Update
------

Method to update one or more users. It has the following signature: function(&lt;User&gt;, &lt;Updates&gt;, &lt;Callback&gt;)

&lt;User&gt; is an object that only needs to contain the right fields to identify the user(s) we want to update. If 'Password' is defined, it will be hashed and used to authenticate the user.

&lt;Updates&gt; is an object that only needs to contain the fields you want to update (if they don't exist, they will be created). If 'Password' is defined among those fields, it will be hashed internally before storage just like in user creation.

&lt;Callback&gt; will have a callback as its first argument and the number of deleted users as its second.

Ex:

```javascript
//Some code

//Here, we pass a plaintext password so we expect successful authentication in order to update the user 
//This might get called on behalf of a user trying to change his password
Store.Update({'Email': 'SomeEmail@email.com', 'Password': 'password!'}, {'Password': 'SlightlyBetterPassword!'}, function(Err, Result) {
    if(Err)
    {
        //Some error occured, handle it. Probably the database.
    }
    else if(Result==1)
    {
        //User was successfully updated
    }
    else if(Result==0)
    {
        //User was not successfully updated. Probably a wrong email or wrong password
    }
});
```

```javascript
//Some code

//Here, we pass a plaintext password is not provided so authentication is not performed.
//This might get called on behalf of an administrator modifying the user from an admin panel
Store.Update({'Email': 'SomeEmail@email.com'}, {'Credits': 100}, function(Err, Result) {
    if(Err)
    {
        //Some error occured, handle it. Probably the database.
    }
    else if(Result==1)
    {
        //User was successfully updated
    }
    else if(Result==0)
    {
        //User was not successfully updated. Probably a wrong email.
    }
});
```

AddMembership
-------------

This function is called to add a group/role to a user. Internally, a set operator is used so the same group/role can't be added multiple times redundantly with this call.

The method has the following signature: function(&lt;User&gt;, &lt;Membership&gt;, &lt;Callback&gt;)

&lt;User&gt; should contain the necessary fields to uniquely identify the user(s) being operated on. It is assumed that this method is called on behalf of someone who has more authority than the user, so a 'Password' property should not be provided. It will not be hashed internally.

&lt;Membership&gt; should correspond to the membership being added.

&lt;Callback&gt; will have a callback as its first argument and the number of updated users as its second.

Ex:

```javascript

//Some code

Store.AddMembership({'Email': 'SomeEmail@email.com'}, 'Banned', function(Err, Result) {
   if(Err)
   {
       //Probably a database error
   }
   else if(Result==1)
   {
       //User successfully banned
   }
   else if(Result==0)
   {
       //Wrong email maybe?
   }
});
```

RemoveMembership
----------------

This function is called to remove a group/role from a user.

The method has the following signature: function(&lt;User&gt;, &lt;Membership&gt;, &lt;Callback&gt;)

&lt;User&gt; should contain the necessary fields to uniquely identify the user(s) being operated on. It is assumed that this method is called on behalf of someone who has more authority than the user, so a 'Password' property should not be provided. It will not be hashed internally.

&lt;Membership&gt; should correspond to the membership being removed.

&lt;Callback&gt; will have a callback as its first argument and the number of updated users as its second.

Ex:

```javascript

//Some code

Store.RemovedMembership({'Email': 'SomeEmail@email.com'}, 'Banned', function(Err, Result) {
   if(Err)
   {
       //Probably a database error
   }
   else if(Result==1)
   {
       //Ban successfully lifted
   }
   else if(Result==0)
   {
       //Wrong email maybe?
   }
});
```

Version History
===============

1.0.0
-----

Initial release

1.0.1
-----

- Removed some dated misleading comments in the code.
- Completed doc
- For default hash, changed default KeyLength from 512 to 20 and Iterations from 1000 to 10000.

1.1.0
-----

Added properties to the error passed to the callback of the 'Add' method if the cause is a restriction (ie, Unique or NotNull) to more easily differentiate those from system errors.

1.1.1
-----

Updated mongodb dependency to version 1.4.29.
